package cryptopwhash

// #cgo pkg-config: libsodium
// #include <stdlib.h>
// #include <sodium.h>
import "C"
import "unsafe"

func CryptoPwhashArgon2iStrbytes() int {
	return int(C.crypto_pwhash_argon2i_strbytes())
}

// The crypto_pwhash_str() function puts an ASCII encoded string into out, which includes:
//
//   * the result of a memory-hard, CPU-intensive hash function applied to the password passwd of length
//     passwdlen
//   * the automatically generated salt used for the previous computation
//   * the other parameters required to verify the password, including the algorithm identifier,
//     its version, opslimit and memlimit.
//
// out must be large enough to hold crypto_pwhash_STRBYTES bytes, but the actual output string may be shorter.
//
// The output string is zero-terminated, includes only ASCII characters and can be safely stored into SQL
// databases and other data stores. No extra information has to be stored in order to verify the password.
//
// The function returns 0 on success and -1 if it didn't complete successfully.
func CryptoPwhashArgon2iStr(passwd string, opslimit, memlimit int) (string, int) {
	passwdlen := len(passwd)
	out := make([]byte, CryptoPwhashArgon2iStrbytes())
	exit := C.crypto_pwhash_argon2i_str(
		(*C.char)(unsafe.Pointer(&out[0])),
		C.CString(passwd),
		C.ulonglong(passwdlen),
		C.ulonglong(opslimit),
		C.size_t(memlimit))

	var result string
	result = C.GoString(C.CString(string(out)))
	return result, int(exit)
}

// This function verifies that the password str is a valid password verification string (as generated by
// crypto_pwhash_str()) for passwd whose length is passwdlen.
//
// str has to be zero-terminated.
//
// It returns 0 if the verification succeeds, and -1 on error.
func CryptoPwhashArgon2iStrVerify(str, passwd string) int {
	passwdlen := len(passwd)
	exit := int(C.crypto_pwhash_argon2i_str_verify(
		C.CString(str),
		C.CString(passwd),
		(C.ulonglong)(passwdlen)))

	return exit
}
